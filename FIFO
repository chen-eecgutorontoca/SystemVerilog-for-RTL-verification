//Author: Bob C

//rtl
/---------------------------------------------------/
module FIFO(
    input clk,
    input rst_n,
    input rd_en,
    input wr_en,
    input [15:0] din,
    output reg [15:0] dout,
    output reg empty,
    output reg full
);
    reg [3:0] wr_ptr;
    reg [3:0] rd_ptr;
    reg [7:0] mem [15:0]; 
 	reg [3:0] cnt;
 
    always @(posedge clk or negedge rst_n) begin
      if (!rst_n)
            wr_ptr <= 4'b0;
        else if (wr_en && !full) 
            wr_ptr <= wr_ptr + 1;
        else
          	wr_ptr <= wr_ptr;
    end

 
    always @(posedge clk or negedge rst_n) begin
      if (!rst_n)
            rd_ptr <= 4'b0;
        else if (rd_en && !empty) 
            rd_ptr <= rd_ptr + 1;
        else
          	rd_ptr <= rd_ptr;
    end


    always @(posedge clk) begin
        if (wr_en && !full)
            mem[wr_ptr] <= din;
        else
          mem[wr_ptr] <= mem[wr_ptr];
    end

    always @(posedge clk) begin
        if (rd_en && !empty)
            dout <= mem[rd_ptr];
        else
          	dout <= dout;
    end
 	
   always@(posedge clk or negedge rst_n)begin
     if(!rst_n)
        cnt <= 4'b0;
     else if(wr_en && !rd_en)
      	cnt <= cnt + 1;
     else if(rd_en && !wr_en)
      	cnt <= cnt - 1;
     else
      	cnt <= cnt;
   end 
  
  assign full = (cnt==4'b1111)? 1:0;
  assign empty = (cnt==4'b0)? 1:0;
  
endmodule
/----------------------------------------------/

//interface
/---------------------------------------------/
interface FIFO_IF;
  
  logic clk;
  logic rst_n;
  logic rd_en, wr_en;
  logic [15:0] din;
  logic [15:0] dout;
  logic empty, full;
  
endinterface
/---------------------------------------------/

/----------------------------------------------/
class transaction;
  bit clk;
  bit rst_n;
  rand bit rd_en, wr_en;
  rand bit [15:0] din;
  bit [15:0] dout;
  bit empty, full;
  
  constraint wr {
    rd_en dist {1 := 50, 0 := 50};
    wr_en dist {1 := 50, 0 := 50};
    rd_en!=wr_en;
  }
  
endclass
/-------------------------------------------/


//Generator
/------------------------------------------------------------------------------------/
class generator;
  transaction tr;
  mailbox #(transaction) mbx;
  virtual FIFO_IF ff;
  
  function new(mailbox #(transaction)mbx);
    this.mbx = mbx;
    tr = new();
  endfunction
  
  task generate_transaction;
    for(int i=0; i<20; i++)begin
      assert(tr.randomize())begin
        mbx.put(tr);
        $display("GEN: wr_en: %0d, rd_en: %0d, din:%0d", tr.wr_en, tr.rd_en, tr.din);
        end else begin
        $display("Randomization Failed!");
        end
      wait (mbx.num() == 0);
    end
  endtask
  
endclass
/---------------------------------------------------------------------------------/


//Driver
/---------------------------------------------------------------------------------/
class driver;
  transaction t;
  mailbox #(transaction) mbx;
  virtual FIFO_IF ff;
  
  function new(mailbox #(transaction) mbx, virtual FIFO_IF ff);
    this.mbx = mbx;
    this.ff = ff; 
  endfunction
  
  task reset;
    ff.rst_n = 1'b0;
    ff.rd_en = 1'b0;
    ff.wr_en = 1'b0;
    ff.din = 15'b0;
    ff.clk = 1'b0;
    #20;
    ff.rst_n = 1;
    $display("Reset Done!");
  endtask
  
  task drive_signals;
    for(int j=0; j<20; j++)begin
      mbx.get(t);
   //   @(posedge ff.clk)
      if(t.wr_en)begin
        ff.wr_en = 1'b1;
      	ff.rd_en = 1'b0;
      	ff.din = t.din;
        $display("DRV: wr_en: %0d, rd_en: %0d, din:%0d", t.wr_en, t.rd_en, t.din);
       end else begin
        ff.wr_en = 1'b0;
      	ff.rd_en = 1'b1;
      	ff.din = t.din;
        $display("DRV: wr_en: %0d, rd_en: %0d, din:%0d", t.wr_en, t.rd_en, t.din);
       end
    end
  endtask
  
endclass


class monitor;
  transaction tr;
  virtual FIFO_IF ff;
  mailbox #(transaction) mbx;
  
  function new(mailbox #(transaction) mbx, virtual FIFO_IF ff);
    this.mbx = mbx;
    this.ff = ff;
    tr = new();
  endfunction
  
  
  task get_signals;
    for(int k=0; k<20; k++)begin
 	@(posedge ff.clk)
    tr.rd_en = ff.rd_en;
    tr.wr_en = ff.wr_en;
    tr.din = ff.din;
    tr.dout = ff.dout;
    tr.empty = ff.empty;
    tr.full = ff.full;
    mbx.put(tr);
    $display("MON: wr_en: %0d, rd_en: %0d, din:%0d, dout:%0d, empty:%0d, full: %0d", 
             tr.wr_en, tr.rd_en, tr.din, tr.dout, tr.empty, tr.full);
    end
  endtask
  
endclass

/------------------------------------------------------------------------------------/

class scoreboard;
  transaction t;
  virtual FIFO_IF ff;
  mailbox #(transaction) mbx;
  
  event next;
  int test_data [$];
  bit golden_output;
  int error_cnt = 0;
  
  function new(mailbox #(transaction) mbx, virtual FIFO_IF ff);
    this.mbx = mbx;
    this.ff = ff;
  endfunction
  
  task compare_results;
    forever begin
      @(posedge ff.clk)
      mbx.get(t);
      if(ff.full)begin
        $display("FIFO FULL");
      end else if (ff.empty)begin
        $display("FIFO EMPTY");         
      end else if(t.wr_en==1 && !t.full)begin
        test_data.push_front(t.din);
      end else if(t.rd_en==1 && !t.empty)begin
        golden_output = test_data.pop_back();
        if(t.dout == golden_output)begin
          $display("TEST PASSED!");
        end else begin
          $display("TEST FAILED! Expected: %0d, Got: %0d", golden_output, t.dout);
          error_cnt++;
        end
      end
      ->next;
    end
  endtask
        
endclass


module tb;
  generator g;
  driver d;
  monitor m;
  mailbox #(transaction) mbx;
  mailbox #(transaction) mbxm;
  FIFO_IF ff();
  
  always #10 ff.clk = ~ff.clk;
  
  FIFO dut(.clk(ff.clk), .rst_n(ff.rst_n), .rd_en(ff.rd_en),
           .wr_en(ff.wr_en), .din(ff.din), .dout(ff.dout),
           .empty(ff.empty), .full(ff.full));
  
  initial begin
 
    mbx = new();
    mbxm = new();
    m = new(mbxm,ff);
    g = new(mbx);
    d = new(mbx,ff);
    d.reset;
	fork
    g.generate_transaction;
    d.drive_signals;
    m.get_signals;
    join_any
  end
  

  
endmodule
